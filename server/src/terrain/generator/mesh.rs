use std::collections::HashMap;
use nalgebra::Vector3;
use nalgebra::Matrix3;
use crate::terrain::{
    coords::{XZCoords, CHUNK_SIZE},
    generator::PaddedHeightmap,
    chunk::ChunkVertex,
};
use crate::entity::Mesh;

// Hermite sample: position and normal at isosurface crossing
struct Hermite {
    /// Position sample on the isosurface
    p: Vector3<f32>,
    /// Surface normal at that sample
    n: Vector3<f32>,
}

pub struct MeshGenerator {
}

impl MeshGenerator {
    pub fn new() -> Self {
        Self {}
    }

    pub fn generate_dual_contour_mesh(
        &self,
        coord: XZCoords,
        padded: &PaddedHeightmap,
        neighborhood: &Vec<ChunkVertex>,
    ) -> Mesh {
        // Constants
        let cs   = CHUNK_SIZE as usize;  // 32
        let grid = cs + 1;               // 33 corners per axis
    
        // Build a cache of any border vertices already generated by neighbors
        let mut cache: HashMap<(i32,i32),(Vector3<f32>,Vector3<f32>)> = HashMap::new();
        for neighbor in neighborhood {
            let base_x = neighbor.grid_x * cs as i32;
            let base_z = neighbor.grid_z * cs as i32;
            for nz in 0..grid {
                for nx in 0..grid {
                    let idx3 = (nz * grid + nx) * 3;
                    let px = neighbor.vertices[idx3];
                    let py = neighbor.vertices[idx3+1];
                    let pz = neighbor.vertices[idx3+2];
                    let nx_ = neighbor.normals[idx3];
                    let ny_ = neighbor.normals[idx3+1];
                    let nz_ = neighbor.normals[idx3+2];
                    cache.insert(
                        (base_x + nx as i32, base_z + nz as i32),
                        (Vector3::new(px,py,pz), Vector3::new(nx_,ny_,nz_))
                    );
                }
            }
        }
    
        // Buffers for this chunk alone
        let mut verts          = Vec::<f32>::with_capacity(grid * grid * 3);
        let mut norms          = Vec::<f32>::with_capacity(grid * grid * 3);
        let mut cell_vertex_idx = vec![vec![None; grid]; grid];
        let mut next_idx       = 0u32;
    
        // PASS 1: one vertex per corner (0..=CS)
        for z in 0..=cs {
            for x in 0..=cs {
                // world-cell coordinate
                let gx = coord.x * cs as i32 + x as i32;
                let gz = coord.z * cs as i32 + z as i32;
                if let Some((pos,nrm)) = cache.get(&(gx,gz)) {
                    verts.extend_from_slice(&[pos.x,pos.y,pos.z]);
                    norms.extend_from_slice(&[nrm.x,nrm.y,nrm.z]);
                    cell_vertex_idx[z][x] = Some(next_idx);
                    next_idx += 1;
                    continue;
                }
                // 1a) Sample four Hermite points at the vertical edges of this corner
                let mut hermites = Vec::with_capacity(4);
                for &(dx, dz) in &[(0,0),(1,0),(1,1),(0,1)] {
                    let sx = x as isize + dx;
                    let sz = z as isize + dz;
                    let h  = padded.get(sx, sz);
                    // world-space position of this surface sample:
                    let p = Vector3::new(
                        coord.x as f32 * cs as f32 + sx as f32,
                        h,
                        coord.z as f32 * cs as f32 + sz as f32,
                    );
                    // approximate normal via finite differences:
                    let dnx = padded.get(sx+1, sz)   - padded.get(sx-1, sz);
                    let dnz = padded.get(sx,   sz+1) - padded.get(sx,   sz-1);
                    let n   = Vector3::new(-dnx, 2.0, -dnz).normalize();
                    hermites.push(Hermite { p, n });
                }
    
                // 1b) Build ATA & ATb for the least-squares solve
                let mut ata = Matrix3::zeros();
                let mut atb = Vector3::zeros();
                for Hermite{ p, n } in &hermites {
                    ata += n * n.transpose();
                    atb += n * n.dot(p);
                }
    
                // 1c) Solve for v (or centroid fallback)
                let mut v = if let Some(inv) = ata.try_inverse() {
                    inv * atb
                } else {
                    // pure average of the 4 sample points
                    hermites.iter()
                            .map(|h| h.p)
                            .fold(Vector3::zeros(), |s,p| s + p)
                        / (hermites.len() as f32)
                };
    
                // 1d) Clamp v.x, v.z to lie within this 1×1 cell
                let base_x = coord.x as f32 * cs as f32 + x as f32;
                let base_z = coord.z as f32 * cs as f32 + z as f32;
                v.x = v.x.clamp(base_x,     base_x + 1.0);
                v.z = v.z.clamp(base_z,     base_z + 1.0);
    
                // 1e) Clamp v.y between the min/max of the four corner heights
                let h00 = padded.get(x as isize,    z as isize);
                let h10 = padded.get(x as isize+1,  z as isize);
                let h01 = padded.get(x as isize,    z as isize+1);
                let h11 = padded.get(x as isize+1,  z as isize+1);
                let min_h = h00.min(h10).min(h01).min(h11);
                let max_h = h00.max(h10).max(h01).max(h11);
                v.y = v.y.clamp(min_h, max_h);
    
                // 1f) Emit vertex & averaged normal
                let normal = hermites.iter()
                                     .map(|h| h.n)
                                     .fold(Vector3::zeros(), |s,n| s + n)
                                     .normalize();

                cache.insert((gx,gz), (v, normal.clone()));

                verts.extend_from_slice(&[v.x, v.y, v.z]);
                norms.extend_from_slice(&[normal.x, normal.y, normal.z]);
    
                // record its index
                cell_vertex_idx[z][x] = Some(next_idx);
                next_idx += 1;
            }
        }
    
        // PASS 2: stitch CS×CS quads (two tris each), CCW winding
        let mut idxs = Vec::<u32>::with_capacity(cs * cs * 6);
        for z in 0..cs {
            for x in 0..cs {
                let a = cell_vertex_idx[z  ][x  ].unwrap();
                let b = cell_vertex_idx[z  ][x+1].unwrap();
                let c = cell_vertex_idx[z+1][x+1].unwrap();
                let d = cell_vertex_idx[z+1][x  ].unwrap();
                // top‐facing triangles: (a,c,b) and (a,d,c)
                idxs.extend_from_slice(&[a, c, b]);
                idxs.extend_from_slice(&[a, d, c]);
            }
        }
    
        Mesh{
            id: 0,
            vertices: verts,
            normals: norms,
            indices: idxs,
            materials: vec![],
        }
    }
}
